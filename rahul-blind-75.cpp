/* Blind LC-75 
1- Two Sum - https://leetcode.com/problems/two-sum/
2- Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
3- Contains Duplicate - https://leetcode.com/problems/contains-duplicate/
4- Product of Array Except Self - https://leetcode.com/problems/product-of-array-except-self/
5- Maximum Subarray - https://leetcode.com/problems/maximum-subarray/
6- Maximum Product Subarray - https://leetcode.com/problems/maximum-product-subarray/
7- Find Minimum in Rotated Sorted Array - https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
8- Search in Rotated Sorted Array - https://leetcode.com/problems/search-in-rotated-sorted-array/
9- 3Sum - https://leetcode.com/problems/3sum/
10- Container With Most Water - https://leetcode.com/problems/container-with-most-water/
Binary
11- Sum of Two Integers - https://leetcode.com/problems/sum-of-two-integers/
12- Number of 1 Bits - https://leetcode.com/problems/number-of-1-bits/
13- Counting Bits - https://leetcode.com/problems/counting-bits/
14- Missing Number - https://leetcode.com/problems/missing-number/
15- Reverse Bits - https://leetcode.com/problems/reverse-bits/
Dynamic Programming
16- Climbing Stairs - https://leetcode.com/problems/climbing-stairs/
17- Coin Change - https://leetcode.com/problems/coin-change/
18- Longest Increasing Subsequence - https://leetcode.com/problems/longest-increasing-subsequence/
19- Longest Common Subsequence -
20- Word Break Problem - https://leetcode.com/problems/word-break/
21- Combination Sum - https://leetcode.com/problems/combination-sum-iv/
22- House Robber - https://leetcode.com/problems/house-robber/
23- House Robber II - https://leetcode.com/problems/house-robber-ii/
24- Decode Ways - https://leetcode.com/problems/decode-ways/
25- Unique Paths - https://leetcode.com/problems/unique-paths/
26- Jump Game - https://leetcode.com/problems/jump-game/
Graph
27- Clone Graph - https://leetcode.com/problems/clone-graph/
28- Course Schedule - https://leetcode.com/problems/course-schedule/
29- Pacific Atlantic Water Flow - https://leetcode.com/problems/pacific-atlantic-water-flow/
30- Number of Islands - https://leetcode.com/problems/number-of-islands/
31- Longest Consecutive Sequence - https://leetcode.com/problems/longest-consecutive-sequence/
32- Alien Dictionary (Leetcode Premium) - https://leetcode.com/problems/alien-dictionary/
33- Graph Valid Tree (Leetcode Premium) - https://leetcode.com/problems/graph-valid-tree/
34- Number of Connected Components in an Undirected Graph (Leetcode Premium) - 
https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
Interval
35- Insert Interval - https://leetcode.com/problems/insert-interval/
36- Merge Intervals - https://leetcode.com/problems/merge-intervals/
37- Non-overlapping Intervals - https://leetcode.com/problems/non-overlapping-intervals/
38- Meeting Rooms (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms/
39- Meeting Rooms II (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms-ii/
Linked List
40- Reverse a Linked List - https://leetcode.com/problems/reverse-linked-list/
41- Detect Cycle in a Linked List - https://leetcode.com/problems/linked-list-cycle/
42- Merge Two Sorted Lists - https://leetcode.com/problems/merge-two-sorted-lists/
43- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
44- Remove Nth Node From End Of List - https://leetcode.com/problems/remove-nth-node-from-end-of-list/
45- Reorder List - https://leetcode.com/problems/reorder-list/
Matrix
46- Set Matrix Zeroes - https://leetcode.com/problems/set-matrix-zeroes/
47- Spiral Matrix - https://leetcode.com/problems/spiral-matrix/
48- Rotate Image - https://leetcode.com/problems/rotate-image/
49- Word Search - https://leetcode.com/problems/word-search/
String
50- Longest Substring Without Repeating Characters - https://leetcode.com/problems/longest-substring-without-repeating-characters/
51- Longest Repeating Character Replacement - https://leetcode.com/problems/longest-repeating-character-replacement/
52- Minimum Window Substring - https://leetcode.com/problems/minimum-window-substring/
53- Valid Anagram - https://leetcode.com/problems/valid-anagram/
54- Group Anagrams - https://leetcode.com/problems/group-anagrams/
55- Valid Parentheses - https://leetcode.com/problems/valid-parentheses/
56- Valid Palindrome - https://leetcode.com/problems/valid-palindrome/
57- Longest Palindromic Substring - https://leetcode.com/problems/longest-palindromic-substring/
58- Palindromic Substrings - https://leetcode.com/problems/palindromic-substrings/
59- Encode and Decode Strings (Leetcode Premium) - https://leetcode.com/problems/encode-and-decode-strings/
Tree
60- Maximum Depth of Binary Tree - https://leetcode.com/problems/maximum-depth-of-binary-tree/
61- Same Tree - https://leetcode.com/problems/same-tree/
62- Invert/Flip Binary Tree - https://leetcode.com/problems/invert-binary-tree/
63- Binary Tree Maximum Path Sum - https://leetcode.com/problems/binary-tree-maximum-path-sum/
64- Binary Tree Level Order Traversal - https://leetcode.com/problems/binary-tree-level-order-traversal/
65- Serialize and Deserialize Binary Tree - https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
66- Subtree of Another Tree - https://leetcode.com/problems/subtree-of-another-tree/
67- Construct Binary Tree from Preorder and Inorder Traversal - 
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
68- Validate Binary Search Tree - https://leetcode.com/problems/validate-binary-search-tree/
69- Kth Smallest Element in a BST - https://leetcode.com/problems/kth-smallest-element-in-a-bst/
70- Lowest Common Ancestor of BST - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
71- Implement Trie (Prefix Tree) - https://leetcode.com/problems/implement-trie-prefix-tree/
72- Add and Search Word - https://leetcode.com/problems/add-and-search-word-data-structure-design/
73- Word Search II - https://leetcode.com/problems/word-search-ii/
Heap
74- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
75- Top K Frequent Elements - https://leetcode.com/problems/top-k-frequent-elements/
76- Find Median from Data Stream - https://leetcode.com/problems/find-median-from-data-stream/
*/

using namespace std;
#include<iostream>
#include<bits/stdc++.h>
#include<vector>
#include<algorithm>

class Solution {
public:
    //1- Two Sum - https://leetcode.com/problems/two-sum/  
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        unordered_map<int, int> m;
        for(int i=0; i<nums.size(); i++){
            if(m.find(target-nums[i])!=m.end()){
                res.emplace_back(i);
                res.emplace_back(m[target-nums[i]]);
                return res;
            }
            m[nums[i]]=i;
        }
        return res;
    }

    //2- Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
    int maxProfit(vector<int>& prices) {
        int lsf = INT_MAX; // least so far
        int op = 0; // overall profit
        int pist = 0; // profit if sold today
        
        for(int i = 0; i < prices.size(); i++){
            if(prices[i] < lsf){ // if we found new buy value which is more smaller then previous one
                lsf = prices[i]; // update our least so far
            }
            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell
            if(op < pist){ // if pist is more then our previous overall profit
                op = pist; // update overall profit
            }
        }
        return op; // return op      
    }

    int maxProfit1(vector<int>& prices) {
        int maax=0;
        int miin=prices[0];
        for(int i=0 ; i<prices.size() ; i++){
            miin=min(prices[i],miin);
            maax=max(prices[i]-miin,maax);
        }
        return maax;     
    }
    //3- Contains Duplicate - https://leetcode.com/problems/contains-duplicate/
    bool containsDuplicate(vector<int>& nums) {
        unordered_map <int, int> mp;
        for (int i = 0; i < nums.size(); i++) {
            if (mp.count(nums[i]) > 0) {
                return true;
            }
            mp[nums[i]] += 1;
        }
        return false;
    }

    //4- Product of Array Except Self - https://leetcode.com/problems/product-of-array-except-self/
    vector<int> productExceptSelf1(vector<int>& nums) {
        int len = nums.size();
        vector<int> left(len,1);
        vector<int> right(len,1);
        vector<int> res(len,1);
        
        left[0] = nums[0];
        for(int i=1; i<len; i++){
            left[i] = left[i-1]*nums[i];
        }
        
        right[len-1]=nums[len-1];
        for(int j=len-2; j>=0; j--){
            right[j] = right[j+1]*nums[j];
        }

        for(int i=0; i<len; i++){
            res[i] = (i-1>=0?left[i-1]:1) * (i+1<len?right[i+1]:1);
        }
        return res;
    }

    vector<int> productExceptSelf(vector<int>& nums) {
        int left = 1, right = 1, n = nums.size();
        vector<int> res(n, 1);
        for(int i=0; i<n; i++) {
            res[i] *= left;
            res[n-i-1] *= right;
            left *= nums[i];
            right *= nums[n-i-1];
        }
        return res;
    }
    
    //5- Maximum Subarray - https://leetcode.com/problems/maximum-subarray/
    int maxSubArray(vector<int>& nums) {
        int sum = 0;
        int maxi= nums[0];
        for(int i =0 ; i<nums.size();i++){
            sum += nums[i];
            maxi = max(maxi,sum);
            if(sum < 0)
                sum = 0;
        }
        return maxi;
    }

    //6- Maximum Product Subarray - https://leetcode.com/problems/maximum-product-subarray/
    int maxProduct1(vector<int>& nums) {
        int n = nums.size();
        vector<int>pre(n), suf(n);
        int mx = nums[0];
        pre[0]=nums[0]; 
        for(int i=1; i<n; i++) {
            if(pre[i-1]!=0) pre[i]=pre[i-1]*nums[i];
            else pre[i]=nums[i];
            mx = max(mx, pre[i]);
        }
        for(int i=n-1; i>=0; i--) {
            if(i==n-1) suf[i]=nums[i];
            else if(suf[i+1]!=0) suf[i]=suf[i+1]*nums[i];
            else suf[i]=nums[i];
            mx = max(mx, suf[i]);
        }
        return mx;    
    }

    int maxProduct(vector<int>& A) {
      // store the result that is the max we have found so far
    int r = A[0];
    int n = A.size();
    // imax/imin stores the max/min product of
    // subarray that ends with the current number A[i]
    for (int i = 1, imax = r, imin = r; i < n; i++) {
        // multiplied by a negative makes big number smaller, small number bigger
        // so we redefine the extremums by swapping them
        if (A[i] < 0)
            swap(imax, imin);

        // max/min product for the current number is either the current number itself
        // or the max/min by the previous number times the current one
        imax = max(A[i], imax * A[i]);
        imin = min(A[i], imin * A[i]);

        // the newly computed max value is a candidate for our global result
        r = max(r, imax);
    }
    return r;
    }

    //7- Find Minimum in Rotated Sorted Array - https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
    // On dividing - one side will be surely sorted and othersise might not
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        if(nums[right] > nums[0]) 
            return nums[0];
        while(left < right){
            int mid = (left + right) / 2;
            if(nums[right] < nums[mid]) 
                left = mid + 1;
            else 
                right = mid;
        }
        return nums[left];
    }

    int findMin1(vector<int>& nums) {
        int low = 0;
        int high = nums.size()-1;
        int miin = INT_MAX;
        
        while(low <= high){
            int mid = (low+high)/2;
            if(nums[mid] <= nums[high]){
                miin = min(nums[mid],miin);
                high = mid-1;
            }else{
                miin = min(nums[low],miin);
                low = mid+1;
            }
        }
        return miin;
    }

    //8- Search in Rotated Sorted Array - https://leetcode.com/problems/search-in-rotated-sorted-array/
    int search(vector<int>& nums, int target) {
        int low=0,high=nums.size()-1;
        
        while(low<=high){
            int mid=(low+high)>>1;
            
            if(nums[mid]==target) 
                return mid;
            
            if(nums[low]<=nums[mid]){
                if(nums[low]<=target && target<=nums[mid]){
                    high=mid-1;
                } else {
                    low=mid+1;
                }
            }
            else{
                if(nums[high]>=target && target>=nums[mid]){
                    low=mid+1;
                }
                else{
                    high=mid-1;
                }
            }
        }
        return -1;
    }

    int search1(vector<int>& nums, int target) {
        int low=0,high=nums.size()-1;
        while(low<high){
            int mid=(low+high)/2;
            if(nums[mid]>nums[high]) low=mid+1;
            else high=mid;
        }
        int point = low;
        low=0,high=nums.size()-1;
        while(low<=high){
            int mid=(low+high)/2;
            int rMid=(mid+point)%nums.size();
            if(nums[rMid]==target) return rMid;
            if(nums[rMid]<target) low=mid+1;
            else high=mid-1;
        }
        return -1;
    }

    //9- 3Sum - https://leetcode.com/problems/3sum/
    vector<vector<int>> threeSum(vector<int>& nums) {
        
        int len = nums.size();
        if(len < 2){
            return {};
        }
        set<pair<int,int>> seen;
        vector<vector<int>> res;
        
        sort(nums.begin(), nums.end());
        for(int i=0; i<len; i++){
            int first = i;
            int second = i+1;
            int end = len-1;
            while(second < end){
                int sum = nums[first] + nums[second] + nums[end];
                if(sum==0){
                    int mi = min(min(nums[first],nums[second]),nums[end]);
                    int ma = max(max(nums[first],nums[second]),nums[end]);
                    if(!seen.count({mi,ma})){
                        res.push_back({nums[first],nums[second],nums[end]});
                    }
                    seen.insert({mi,ma});
                    second++;
                    end--;
                }else if(sum > 0){
                    end--;
                }else{
                    second++;
                }
            }
        }
        return res;
    }

    vector<vector<int>> threeSum1(vector<int>& arr) {
        int n = arr.size();
        if(n == 0)
            return {};
        
        sort(arr.begin(), arr.end());
        vector<vector<int>> res;
        
        for(int i = 0; i <= n - 3; i++)
        {
            int target = - arr[i];
            int low = i + 1;
            int high = n - 1;
    
            while(low < high)
            {
                if(arr[low] + arr[high] == target)
                {
                    res.push_back({arr[i], arr[low], arr[high]});
                    //skip duplicates
                    while(low < high && arr[low] == arr[low + 1]){
                        low++;
                    }
                    //skip duplcates
                    while(low < high && arr[high] == arr[high - 1]){
                        high--;
                    }
                    low++;
                    high--;
                } else if(arr[low] + arr[high] < target) {
                    low++;
                } else {
                    high--;
                }
            }
            //skip duplicates
            while(i < n - 3 && arr[i] == arr[i + 1])
            {
                i++;
            }
        }
        
        return res;
    }

    //10- Container With Most Water - https://leetcode.com/problems/container-with-most-water/
    //https://medium.com/j-t-tech/leetcode-11-container-with-most-water-cd10c0064034
    int maxArea(vector<int>& height) {
        int ans=0,cal=0;
        int i=0,j=height.size()-1;
        while(i<j){
            if(height[i]<height[j]){
                cal=height[i]*(j-i);
                i++;
            }
            else{
                cal=height[j]*(j-i);
                j--;
            }
            ans=max(ans,cal);
        }
        return ans;
    }

    // Bonus -Trapping Rain Water - https://leetcode.com/problems/trapping-rain-water/   (sounds similar to above but different - thing twice)
    //https://medium.com/j-t-tech/leetcode-42-trapping-rain-water-c7e6e4e3b671
    //Similar to Container With Most Water, the amount of water that can be contained is an area that is bounded in height by the shortest wall on the left and right. 
    //However, in this problem the heights have widths and displace water, AND we need all the containers.
    int trap(vector<int>& height){
        int n = height.size();
        int left = 0;
        int right = n-1;
        int res = 0;
        int maxleft = 0, maxright=0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left]>=maxleft)
                    maxleft = height[left];
                else    
                    res += maxleft-height[left];
                left++;
            } else {
                if(height[right]>=maxright)
                    maxright = height[right];
                else    
                    res += maxright-height[right];
                right--;
            }
        }
        return res;
    }

    //11- Sum of Two Integers - https://leetcode.com/problems/sum-of-two-integers/
    int getSum1(int a, int b) {
        while(b){
            unsigned c=a&b;
            a=a^b;
            b=c<<1;
        }
        return a;
    }
    
    int getSum(int a, int b) {     
        if(b>0){
             while(b>0){
                a++;
                b--;
            }  
        } else {
            while(b<0)
            {
                a--;
                b++;
            }
        }
        return a;
    }

    //12- Number of 1 Bits - https://leetcode.com/problems/number-of-1-bits/
    int hammingWeight1(uint32_t n) {
        int count=0;
        while(n){
            if(n & 0x1)
                count++;
            n = n >> 1;
        }
        return count;
    }

    int hammingWeight(uint32_t n) {
        int count=0;
        while(n){
            n = n & n-1;
            count++;
        }
        return count;
    }

    //13- Counting Bits - https://leetcode.com/problems/counting-bits/
    vector<int> countBits(int n) {
        vector<int> res;
        for(int i=0; i<=n; i++){
            res.push_back(hammingWeight(i));
        }
        return res;
    }

    //14- Missing Number - https://leetcode.com/problems/missing-number/
    int missingNumber(vector<int>& nums) {
        int xor1 = 0, i = 0;
	    for (i = 0; i < nums.size(); i++) {
		    xor1 = xor1 ^ i ^ nums[i];
	    }
	    return xor1 ^ i;    
    }

    //15- Reverse Bits - https://leetcode.com/problems/reverse-bits/
    uint32_t reverseBits(uint32_t n) {
        uint32_t ans;
        for(int i=0;i<32;i++){
            ans<<=1;
            if(n & 1) 
                ans++;
            n=n>>1;
        }
        return ans;    
    }
/*
16- Climbing Stairs - https://leetcode.com/problems/climbing-stairs/
17- Coin Change - https://leetcode.com/problems/coin-change/
18- Longest Increasing Subsequence - https://leetcode.com/problems/longest-increasing-subsequence/
19- Longest Common Subsequence -
20- Word Break Problem - https://leetcode.com/problems/word-break/
21- Combination Sum - https://leetcode.com/problems/combination-sum-iv/
22- House Robber - https://leetcode.com/problems/house-robber/
23- House Robber II - https://leetcode.com/problems/house-robber-ii/
24- Decode Ways - https://leetcode.com/problems/decode-ways/
25- Unique Paths - https://leetcode.com/problems/unique-paths/
26- Jump Game - https://leetcode.com/problems/jump-game/
*/

    //27- Clone Graph - https://leetcode.com/problems/clone-graph/
    // Definition for a Node.
    class Node {
    public:
    int val;
    vector<Node*> neighbors;
    Node() {
        val = 0;
        neighbors = vector<Node*>();
    }
    Node(int _val) {
        val = _val;
        neighbors = vector<Node*>();
    }
    Node(int _val, vector<Node*> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
    };

    //BFS
    Node* cloneGraph(Node* node) {
        if(node == NULL){ // if node is null, then simply return null
            return NULL;
        }
        unordered_map<Node *, Node *> mp;
        Node* first = new Node(node -> val, {}); // make a copy of first node
        mp[node] = first;
        
        queue<Node*> q; //For bfs, we create queue
        q.push(node); // push into queue
        
        while(q.empty() == false){ // until q. empty == false
            Node* curr = q.front(); // extract front node
            q.pop(); // pop that from queue
            
            for(auto adj: curr -> neighbors){ // now travel in adjcant
                if(mp.find(adj) == mp.end()){ // if not present in map
                    mp[adj] = new Node(adj -> val, {}); // then create copy
                    q.push(adj); // push nto the queue
                }
                
                mp[curr] -> neighbors.push_back(mp[adj]); // in current node push adjcant node
            }
        }
        
        return mp[node];
    }
    //DFS
    void dfs1(Node *key, unordered_map<Node*, Node*>&clone) {
        Node *new_node = new Node(key->val);
        clone[key] = new_node;
        
        for (auto node: key->neighbors) {
            if (clone.find(node) == clone.end())
                dfs1(node, clone);
            new_node->neighbors.push_back(clone[node]);
        }
    }
    Node* cloneGraph1(Node* node) {
        if (!node)
            return nullptr;
        unordered_map<Node*, Node*> clone;
        
        dfs1(node, clone);
        return clone[node];
    }

    /* 28- Course Schedule - https://leetcode.com/problems/course-schedule/
    There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
    For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
    Return true if you can finish all courses. Otherwise, return false.
    */
    /* vis[id]=0 is used for node which is not yet visited, 
       vis[id]=1 is used for the node which is visited and currently its child nodes are being visited and 
       vis[id]=2 done when all the child nodes of a node ("id") are visited and the function returns to parent node of node ("id"). 
       So at that time it is marked as 2 because this node does not require any further traversing.
    */
    bool iscycle(vector<int> adj[],vector<int> &vis,int id){
        if(vis[id]==1)
            return true;
        if(vis[id]==0){
            vis[id]=1;
            for(auto edge : adj[id]){
                if(iscycle(adj,vis,edge))
                    return true;
            }
        }
        vis[id] = 2; //the node is no longer in the recursive stack.
        return false;
    }
    bool canFinish(int n, vector<vector<int>>& pre) {
        vector<int> adj[n];
        
        for(auto edge : pre)
            adj[edge[1]].push_back(edge[0]);
        
        vector<int> vis(n,0);
        for(int i=0;i<n;i++){
            if(iscycle(adj,vis,i))
                return false;
        }
        return true;
    }

    //29- Pacific Atlantic Water Flow - https://leetcode.com/problems/pacific-atlantic-water-flow/
    // https://leetcode.com/problems/pacific-atlantic-water-flow/discuss/2641884/Solution-Explain-%2B-C%2B%2B-Code
    // Go througout the adjacent if the adjacent's height is more or equal to current height
	void dfs(vector<vector<int>>& grid, vector<vector<bool>>& flag, int x, int y) {
        int n = flag.size();
        int m = flag[0].size();
        
		flag[x][y] = true;
		if (x - 1 >= 0 && !flag[x - 1][y] && grid[x - 1][y] >= grid[x][y])
			dfs(grid, flag, x - 1, y);
		if (x + 1 < n && !flag[x + 1][y] && grid[x + 1][y] >= grid[x][y])
			dfs(grid, flag, x + 1, y);
		if (y - 1 >= 0 && !flag[x][y - 1] && grid[x][y - 1] >= grid[x][y])
			dfs(grid, flag, x, y - 1);
		if (y + 1 < m && !flag[x][y + 1] && grid[x][y + 1] >= grid[x][y])
			dfs(grid, flag, x, y + 1);
	}

	vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
		int n = heights.size();
		int m = heights[0].size();

		vector<vector<bool>> flag1(n, vector<bool>(m)), flag2(n, vector<bool>(m));
		vector<vector<int>> ans;

		// Pacific
		// Do DFS starting from upper border and left border
		// Mark true in flag1 if posibble
		for (int i = 0; i < n; i++)
			dfs(heights, flag1, i, 0);
		for (int i = 1; i < m; i++)
			dfs(heights, flag1, 0, i);

		// Attlantic
		// DFS starting from bottom border and right border
		// Mark true in flag2 if posibble
		for (int i = 0; i < n; i++)
			dfs(heights, flag2, i, m - 1);
		for (int i = 0; i < m - 1; i++)
			dfs(heights, flag2, n - 1, i);

		// Add cordinate to ans if both flag1 and flag2 is equal to true
		for (int i = 0; i < n; i++) 
            for (int j = 0; j < m; j++)
			    if (flag1[i][j] && flag2[i][j])
				    ans.push_back({i, j});

		return ans;
	}
    
    // 30- Number of Islands - https://leetcode.com/problems/number-of-islands/
    void getIslands(vector<vector<char>> &grid, int i, int j, int row, int col){
        
        if(i<0 || i>=row || j<0 || j>=col || grid[i][j]=='0')
            return;
        
        grid[i][j]='0';
        getIslands(grid,i+1,j,row,col);
        getIslands(grid,i-1,j,row,col);
        getIslands(grid,i,j+1,row,col);
        getIslands(grid,i,j-1,row,col);
    }

    int numIslands(vector<vector<char>>& grid) {
       int row = grid.size();
        if(row==0)
            return 0;
        int col = grid[0].size();
        int count=0;
        for(int i=0; i<row; i++){
            for(int j=0; j<col; j++){
                if(grid[i][j]=='1'){
                    count++;
                    getIslands(grid,i,j,row,col);
                }
            }
        }
        return count;
    }

    //31- Longest Consecutive Sequence - https://leetcode.com/problems/longest-consecutive-sequence/
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> hashSet;
        for(int num: nums){
            hashSet.insert(num);
        }
        int longestSteak = 0;
        for(int num: nums){
           if(!hashSet.count(num-1)){
               int currentNum = num;
               int currentSteak = 1;

               while(hashSet.count(currentNum+1)){
                   currentNum += 1;
                   currentSteak +=1 ;
               }

               longestSteak = max(longestSteak, currentSteak);
           }
       }
       return longestSteak;

    }

    //32- Alien Dictionary (Leetcode Premium) - https://leetcode.com/problems/alien-dictionary/
    //https://leetcode.com/discuss/interview-question/248131/microsoft-interview-round-1-alien-dictionary    
    //https://www.tutorialcup.com/leetcode-solutions/alien-dictionary-leetcode-solution.htm
    /*
    Let’s understand the problem statement first

words are sorted lexicographically which means if W[i] appears in the dictionary before W[j] for i < j.
Please note that individual words are not sorted. If abcde appears before abpqrst that doesn’t mean b appears before a.
Main things to note:

1. In a dictionary of words, for any two consecutive words, the order is decided by looking at the first uncommon char.
2. The chars following the uncommon char can’t be relied upon to conclude in any order. The reason being the order between the words was decided purely based on the first mismatching char, so any char after that is only there to constitute the complete word.

3. The consecutive chars appearing in any word has nothing to do with the order but they are there just to form the complete word.

Approach:

1. Create Graph: Using the above points, we iterate through consecutive word pairs and try to create edges.
2. Topological Sort: This can be done using DFS or BFS. I decided to go with BFS here

Edge cases

["abc", "ab"] – it’s not a valid dictionary, if W[i] < W[j] in the dictionary then W[j] can not be prefix of W[i]. so in this case simply return an empty string.
["a", "b", "a"] – here in this input, a < b and b < a, which is a cycle. a dictionary can not contain a cycle.

*/
    // Finds the topological order of a directed Acyclic graph
    string topologicalSortBFS(unordered_map<char, unordered_set<char>> &g) {
        unordered_map<char, int> indegree;
        queue<char> q;
        // topological order
        string order;
        
        // Compute the indegree of each node
        for(auto u: g) {
            char src = u.first;
            for(auto neighbor: g[src]) 
                ++indegree[neighbor];
        }
        
        // if current has no dependency, add and mark as visited
        for(auto u: g) {
            char src = u.first;
            if(!indegree[src]) {
                q.emplace(src);
            }
        }
                // BFS traversal wrt to indegree of each node
        while(!q.empty()) {
            auto curr = q.front();
            q.pop();
            order += curr;
            
            // reduce the indegree of its neighbors
            for(auto neighbor: g[curr]) {
                --indegree[neighbor];
                if(!indegree[neighbor]) 
                    q.emplace(neighbor);
            }
        }
        return order.size() < g.size() ? "" : order;
    }
    string alienOrder(vector<string>& words) {
        // create a graph
        // To create a graph using the lexographic order,
        // we need to look at the consecutive word pairs and 
        // within the common length check for diff chars at the same
        // index position, each unequal pair is a directed edge coming
        // from words[i][j] to words[i+1][j]
        unordered_map<char, unordered_set<char>> g;
        // initialize the graph with nodes req
        for(auto &word: words)
            for(char &ch: word)
                if(!g.count(ch))
                    g[ch] = unordered_set<char>();
        
        // Imp: Add all the seen chars to graph even with 0 edges
        for(int w = 0; w + 1 < words.size(); w++) {
            int common_len = min(words[w].size(), words[w+1].size());
            // check if the lexographic order is being followed or not
            // P.S I dont think this case is even valid acc to problem description
            // Eg: ["abc", "ab"] -> Invalid
            if(words[w+1].size() < words[w].size() 
               && words[w].substr(0, common_len) == words[w+1])
                return "";
                    for(int i = 0; i < common_len; i++) {
                // prevent self loop
                char src = words[w][i], dst = words[w+1][i];
                // If current pos has diff chars, then make an edge and
                // break since, the current word ordering was due this positional char
                // change and anything beyond this might not follow actual order.
                if(src != dst) {
                    g[src].emplace(dst);
                    break;
                }
            }
        }
        
        string order = topologicalSortBFS(g);
        return order;
    }
 
    //33- Graph Valid Tree (Leetcode Premium) - https://leetcode.com/problems/graph-valid-tree/
    bool isCyclic(map<int, vector<int>> &adj, vector<int>&vis, int v, int u) {
        if(vis[v]) return 1;
        vis[v]=1;
        for(int neighbor:adj[v]) {
            if(neighbor != u && isCyclic(adj, vis, neighbor, v)) 
                return 1;
        }
        return 0;
    }
    
    bool validTree(int n, vector<vector<int>>& edges) {
        // contruct graph using map
        map<int, vector<int>> adj;
        for(auto &edge: edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
        
        vector<int> vis(n,0);
        
        if(isCyclic(adj, vis, 0, -1))
            return 0;
        
        for(int i=0; i<n; i++) {
            if(!vis[i])
                return 0;
        }
        
        return 1;
    }

    //34- Number of Connected Components in an Undirected Graph (Leetcode Premium) - 
    //https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
    //https://www.tutorialspoint.com/number-of-connected-components-in-an-undirected-graph-in-cplusplus
    void dfs(int node, vector<int> graph[], vector<bool>& visited){
      if(visited[node]) return;
         visited[node] = true;
      for(int i = 0; i < graph[node].size(); i++){
         dfs(graph[node][i], graph, visited);
      }
    }
    
    int countComponents(int n, vector<vector<int>>& edges) {
      vector <bool> visited(n);
      if(!n) return 0;
      vector <int> graph[n];
      for(int i = 0; i < edges.size(); i++){
         int u = edges[i][0];
         int v = edges[i][1];
         graph[u].push_back(v);
         graph[v].push_back(u);
      }
      int ret = 0;
      for(int i = 0; i < n; i++){
         if(!visited[i]){
            dfs(i, graph, visited);
            ret++;
         }
      }
      return ret;
    }

    //35- Insert Interval - https://leetcode.com/problems/insert-interval/
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> res;
        int len = intervals.size();
        int index = 0;
        
        //insert all the intervals to the result that are left to the new interval
        while((index < len) && (intervals[index][1] < newInterval[0])){
            res.push_back(intervals[index]);
            index++;
        }
        
        //merge all intervals that intersect with the new interval
        while(index < len && intervals[index][0] <= newInterval[1]){
            newInterval[0] = min(intervals[index][0],newInterval[0]);
            newInterval[1] = max(intervals[index][1],newInterval[1]);
            index++;
        }
        res.push_back(newInterval);
        
        //put all that is rest to this interval
        while(index < len){
            res.push_back(intervals[index]);
            index++;
        }
        
        return res;  
    }

    //36- Merge Intervals - https://leetcode.com/problems/merge-intervals/
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if(intervals.size())
            return res;

        sort(intervals.begin(), intervals.end());
        vector<int> inter = intervals[0];
        
        for(int i=1; i<intervals.size(); i++){
            if(inter[1] >= intervals[i][0]){
                //inter[0] = min(inter[0], intervals[i][0]); //this is obvious as we have sorted intervals
                inter[1] = max(inter[1], intervals[i][1]);
            } else {
                res.push_back(inter);
                inter = intervals[i];
            }
        }
        res.push_back(inter);
        return res;
    }

    //37- Non-overlapping Intervals - https://leetcode.com/problems/non-overlapping-intervals/
    /* note that in previous overalapping problems we were sorting based
    on first index, here we are sorting based on second index because if they
    are non overlapping intervals the first index will be in already sorted if not
    then remove that pair*/
    static bool comp(vector<int> &a,vector<int> &b) {
	    return a[1]<b[1];
    }

    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int ans=0;      
		int n=intervals.size();       
		sort(intervals.begin(),intervals.end(),comp); 
		vector<int> prev= intervals[0];
		for(int i=1;i<n;i++){
			if(prev[1]>intervals[i][0]) {
				ans++;              
			} else { 
                prev=intervals[i];           
            }
		}
		return ans;                 
    }
    //38- Meeting Rooms (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms/
    //https://spacedleet.vercel.app/solutions/meeting-rooms/cpp
    struct Interval {
        int start;
        int end;
        Interval() : start(0), end(0) {}
        Interval(int s, int e) : start(s), end(e) {}
    };
    bool overlapped(const Interval& i1, const Interval& i2){
        return max(i1.start, i2.start) < min(i1.end, i2.end);
    }
    
    bool canAttendMeetings(vector<Interval>& intervals) {
        for(int i = 0; i < intervals.size(); i ++)
            for(int j = i + 1; j < intervals.size(); j ++)
                if(overlapped(intervals[i], intervals[j]))
                    return false;
        return true;
    }

    //39- Meeting Rooms II (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms-ii/
    //https://www.tutorialcup.com/leetcode-solutions/meeting-rooms-ii-leetcode-solution.htm
    int minMeetingRooms(vector<vector<int>> &intervals){
        if(intervals.size())
            return 0;

        vector<int> start;
        vector<int> end;
        for (int i = 0; i < intervals.size(); i++){
            start.push_back(intervals[i][0]);
            end.push_back(intervals[i][1]);
        }
        sort(start.begin(), start.end());
        sort(end.begin(), end.end());
        int i = 1, j = 0;
        int curr = 1;
        int answer = 1;
        while (i < start.size() && j < end.size()){
            if (start[i] < end[j]){
                curr++;
                i++;
            } else {
                curr--;
                j++;
            }
            answer = max(answer, curr);
        }
        return answer;
    }

    //40- Reverse a Linked List - https://leetcode.com/problems/reverse-linked-list/
    struct ListNode {
      int val;
      ListNode *next;
      ListNode() : val(0), next(nullptr) {}
      ListNode(int x) : val(x), next(nullptr) {}
      ListNode(int x, ListNode *next) : val(x), next(next) {}
    };
    //iterative
    ListNode* reverseList(ListNode* head) {
        ListNode * next = NULL;
        ListNode * temp = head;
        while(head!=NULL){
            temp = head->next;
            head->next = next;
            next = head;
            head = temp;
        }
        return next;
    }

    //recurssive
    ListNode* recursivereverselist(ListNode* head,ListNode* prev){
        if(head == NULL)
            return prev;
        ListNode* after = head->next;
        head->next = prev;
        return recursivereverselist(after,head);
    }
    ListNode* reverseList1(ListNode* head) {
        return recursivereverselist(head,NULL);
    }

    //41- Detect Cycle in a Linked List - https://leetcode.com/problems/linked-list-cycle/
    bool hasCycle(ListNode *head) {
        if(head==NULL)
            return false;
        if(head->next==NULL)
            return false;
        if(!head->next && head==head->next)
            return true;
        
        ListNode *slow=head;
        ListNode *fast=head->next->next;
        
        while(fast && fast->next){
            if(fast == slow)
                return true;
            fast = fast->next->next;
            slow = slow->next;
        }
        return false;
    }

    bool hasCycle1(ListNode *head) {
        ListNode * slow = head;
        ListNode * fast = head;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast)
                return true;
        }
        return false;
    }

    //42- Merge Two Sorted Lists - https://leetcode.com/problems/merge-two-sorted-lists/
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1==NULL)
            return list2;
        if(list2==NULL)
            return list1;
        
        ListNode result;
        ListNode *tail;
        tail = &result;
        
        while(list1 && list2){
            if(list1->val <= list2->val){
                tail->next = list1;
                list1 = list1->next;
            } else {
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next;
        }
        
        if(list1){
            tail -> next = list1;
        }
        if(list2){
            tail -> next = list2;
        }
        
        return result.next;
    }

    //43- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
    //https://leetcode.com/problems/merge-k-sorted-lists/discuss/1746240/C%2B%2B-Solution-w-Explanation-or-Step-by-step-optimisation-or-Three-different-approaches
    class comp2{
        public:
        bool operator()(ListNode *a, ListNode *b){
            return a->val > b->val;
        }
    };
        
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size()==0)
            return NULL;
        
        int count=0;
        ListNode dummy;
        ListNode *res = &dummy;
        priority_queue<ListNode *, vector<ListNode*>, comp2> pq;
        int len = lists.size();
        
        while(true){
            count=0;
            for(int i=0 ; i < lists.size() ; i++){
                if(lists[i]){
                    pq.push(lists[i]);
                    lists[i] = lists[i]->next;
                } else {
                    count++;
                }
            }
           // cout<<" "<<count<<endl;
            if(!pq.empty()){
                res->next = pq.top();
                res = res->next;
                pq.pop();
            }
            if(count==len)
                break;
        }
        while(!pq.empty()){
            res->next = pq.top();
            res = res->next;
            pq.pop();        
        }
        res->next = nullptr;
        
        return dummy.next;
    }

    //44- Remove Nth Node From End Of List - https://leetcode.com/problems/remove-nth-node-from-end-of-list/
        ListNode* removeNthFromEnd(ListNode* head, int n) {
        /* two pointers, first and second
            first traverse till n nodes
            second traverse till n reaches end
        */
        ListNode* f = head,*s=head;
        while(n-- && f) 
            f=f->next;
        if(!f) 
            return head->next;
        while(f && f->next){
            f=f->next;
            s=s->next;
        }
        s->next = s->next->next;
        
        return head;    
    }

    //45- Reorder List - https://leetcode.com/problems/reorder-list/
    void reorderList(ListNode* head) {
        if ((!head) || (!head->next) || (!head->next->next)) 
            return; // Edge cases
        
        stack<ListNode*> my_stack;
        ListNode* ptr = head;
        int size = 0;
        while (ptr != NULL){ // Put all nodes in stack
            my_stack.push(ptr);
            size++;
            ptr = ptr->next;
        }
        
        ListNode* pptr = head;
        for (int j=0; j<size/2; j++){ // Between every two nodes insert the one in the top of the stack
            ListNode *element = my_stack.top();
            my_stack.pop();
            element->next = pptr->next;
            pptr->next = element;
            pptr = pptr->next->next;
        }
        pptr->next = NULL;
    }

    //46- Set Matrix Zeroes - https://leetcode.com/problems/set-matrix-zeroes/
    //https://spacedleet.vercel.app/solutions/set-matrix-zeroes/cpp
    //strivers placement series 
    void setZeroes(vector<vector<int>>& matrix) {
        bool bFirstColZero = false;
        int rows = matrix.size(); 
        int cols = matrix[0].size();
        
        for (int i=0; i<rows; ++i) {
            if (matrix[i][0] == 0) 
                bFirstColZero = true;
            for (int j=1; j<cols; ++j)
                if (matrix[i][j] == 0) 
                    matrix[i][0] = matrix[0][j] = 0;
        }
        
        for (int i=rows-1; i>=0; --i) {
            for (int j=cols-1; j>0; --j)
                if (matrix[i][0] == 0 || matrix[0][j] == 0) 
                    matrix[i][j] = 0;
            if (bFirstColZero) 
                matrix[i][0] = 0;
        }
    }

    //47- Spiral Matrix - https://leetcode.com/problems/spiral-matrix/

    //48- Rotate Image - https://leetcode.com/problems/rotate-image/
    void reverse(vector<int>& matrix){
        int i=0;
        int j=matrix.size()-1;
        while(i<j){
            int temp = matrix[i];
            matrix[i] = matrix[j];
            matrix[j] = temp;i++;j--;
        }
    }
    //public:
    void rotate(vector<vector<int>>& matrix) {
        int rows = matrix.size();
        int cols = matrix[0].size();
        
        //transpose of the matrix
        for(int i=0; i<rows; i++){
            for(int j=i+1; j<cols; j++){
                //if(i < j){
                    int temp = matrix[i][j];
                    matrix[i][j] = matrix[j][i];
                    matrix[j][i] = temp;
                //}
            }
        }

        //reverse each row
        for(int i=0; i<rows; i++){
            reverse(matrix[i]);
        }
        return;
    }

    //49- Word Search - https://leetcode.com/problems/word-search/
    //boundary check
    bool isvalid(int i,int j,int n,int m){
        if(i>=0 &&i<n &&j>=0 &&j<m) 
            return true;
        return false;
    }
    bool  existword(vector<vector<char>>& board, string word,int index,vector<vector<bool>>& visit,int x,int y){
        int m,n;
        n=board.size();
        m=board[0].size();
      
        //if we reach till end we must found the word so return true
        if(index==word.size()){
              return true;
        }
      
        //four directions
        int dx[]={1,0,-1,0};
        int dy[]={0,1,0,-1};
      
        for(int i=0;i<4;i++){
            int newx=x+dx[i];
            int newy=y+dy[i];
            
            //check if the char match with the direction and if it is visited or not
            if(isvalid(newx,newy,n,m) && 
                board[newx][newy]==word[index] && 
                visit[newx][newy]==false){
                
                //if we are going to that index mark this visited
                visit[newx][newy]=true;
                if(existword(board,word,index+1,visit,newx,newy)) 
                    return true;
            
                //if ans not found mark this false so it can be included in other search
                visit[newx][newy]=false;
            }
        }
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        int m,n,i,j;
        n=board.size();
        m=board[0].size();
    
        //vector to check if node visited or not(already included or not)
        vector<vector<bool>> visit(n,vector<bool>(m,false));
    
        //loop to check from where to start, start only when first char match
        for(i=0;i<n;i++){
            for(j=0;j<m;j++){
                //mark 1st char visited
                visit[i][j]=true;
            
                //check the condition if it matchs first char call function for  the rest
                if(board[i][j]==word[0] && existword(board,word,1,visit,i,j)) 
                    return true;
            
                //if not found with previous search mark this as false, so it can be used with others
                visit[i][j]=false;
            }
        }
        return false;
    }

    //50- Longest Substring Without Repeating Characters - https://leetcode.com/problems/longest-substring-without-repeating-characters/
    int lengthOfLongestSubstring(string s) {
        int freq[256] = {0};

        int l = 0, r = -1; // sliding window: s[l...r]
        int res = 0;

        while(r + 1 < s.size()){

            if( freq[s[r + 1]] == 0 )
                freq[s[++r]] ++;
            else    //freq[s[r+1]] == 1
                freq[s[l++]] --;

            res = max(res, r - l + 1);
        }

        return res;
    }

    int lengthOfLongestSubstring1(string s) {

        int last[256];
        memset(last, -1, sizeof(last));

        int l = 0, r = -1; // sliding window: s[l...r]
        int res = 0;
        while(r + 1 < s.size()){

            r ++;
            if(last[s[r]] != -1)
                l = max(l, last[s[r]] + 1);

            res = max(res, r - l + 1);
            last[s[r]] = r;
        }

        return res;
    }

    //51- Longest Repeating Character Replacement - https://leetcode.com/problems/longest-repeating-character-replacement/
    int characterReplacement(string s, int k) {
         // Base case...
        if (s.size() == 0) return 0;
        // Make an array...
        vector <int> arr(128);
        // Initialize largestCount & beg pointer...
        int beg = 0, largestCount = 0;
        // Traverse all characters through the loop...
        for (int end = 0; end < s.size(); end++) {
            // Get the largest count of a single, unique character in the current window...
            largestCount = max(largestCount, ++arr[s[end]]);
            // We are allowed to have at most k replacements in the window...
            // So, if max character frequency + distance between beg and end is greater than k...
            // That means we have met a largest possible sequence, we can move the window to right...
            if (end - beg + 1 - largestCount > k) // The main equation is: end - beg + 1 - largestCount...
                arr[s[beg++]]--;
        }
        // Return the sequence we have passes, which is s.length() - beg...
        return s.length() - beg;
    }
    
    //52- Minimum Window Substring - https://leetcode.com/problems/minimum-window-substring/

    //53- Valid Anagram - https://leetcode.com/problems/valid-anagram/
    bool isAnagram(string s, string t) {
        int count[26]={0};
        
        for(int i=0; i<s.size(); i++){
            count[s[i]-'a']++;
        }
        for(int i=0; i<t.size(); i++){
            count[t[i]-'a']--;
        }
        for(int i=0; i< 26; i++){
            if(count[i]!=0)
                return false;
        }
        return true;
    }

    //54- Group Anagrams - https://leetcode.com/problems/group-anagrams/
        vector<vector<string>> groupAnagrams(vector<string>& strs) {
        map<string,vector<string>>m;
        vector<vector<string>> res;
        
        for(int i=0; i<strs.size(); i++){
            string s = strs[i];
            sort(s.begin(),s.end());
            m[s].push_back(strs[i]);
        }
        for(auto it=m.begin(); it!=m.end(); it++){
            res.push_back(it->second);
        }
        
        return res;
    }

    //55- Valid Parentheses - https://leetcode.com/problems/valid-parentheses/
    bool isValid(string s) {
        
        stack<char> st;
        for(char ch:s){
            if(ch=='(' || ch=='[' || ch=='{'){
                st.push(ch);
            }else{
                if(st.empty())
                    return false;
                if(ch==')' && st.top()=='(' ||
                   ch==']' && st.top()=='[' ||
                   ch=='}' && st.top()=='{')
                    st.pop();
                else
                    return false;
            }
        }
        return st.empty();
    }
/*
56- Valid Palindrome - https://leetcode.com/problems/valid-palindrome/
57- Longest Palindromic Substring - https://leetcode.com/problems/longest-palindromic-substring/
58- Palindromic Substrings - https://leetcode.com/problems/palindromic-substrings/
59- Encode and Decode Strings (Leetcode Premium) - https://leetcode.com/problems/encode-and-decode-strings/
Tree
60- Maximum Depth of Binary Tree - https://leetcode.com/problems/maximum-depth-of-binary-tree/
61- Same Tree - https://leetcode.com/problems/same-tree/
62- Invert/Flip Binary Tree - https://leetcode.com/problems/invert-binary-tree/
63- Binary Tree Maximum Path Sum - https://leetcode.com/problems/binary-tree-maximum-path-sum/
64- Binary Tree Level Order Traversal - https://leetcode.com/problems/binary-tree-level-order-traversal/
65- Serialize and Deserialize Binary Tree - https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
66- Subtree of Another Tree - https://leetcode.com/problems/subtree-of-another-tree/
67- Construct Binary Tree from Preorder and Inorder Traversal - 
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
68- Validate Binary Search Tree - https://leetcode.com/problems/validate-binary-search-tree/
69- Kth Smallest Element in a BST - https://leetcode.com/problems/kth-smallest-element-in-a-bst/
70- Lowest Common Ancestor of BST - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
71- Implement Trie (Prefix Tree) - https://leetcode.com/problems/implement-trie-prefix-tree/
72- Add and Search Word - https://leetcode.com/problems/add-and-search-word-data-structure-design/
73- Word Search II - https://leetcode.com/problems/word-search-ii/
*/

    //74 - Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
      class comp1{
        public:
        bool operator()(ListNode *a, ListNode *b){
        return a->val > b->val;
        }
    };
        
    ListNode* mergeKLists1(vector<ListNode*>& lists) {
        if(lists.size()==0)
            return NULL;
        
        int count=0;
        ListNode dummy;
        ListNode *res = &dummy;
        priority_queue<ListNode *, vector<ListNode*>, comp1> pq;
        int len = lists.size();
        
        while(true){
            count=0;
            for(int i=0 ; i < lists.size() ; i++){
                if(lists[i]){
                    pq.push(lists[i]);
                    lists[i] = lists[i]->next;
                } else {
                    count++;
                }
            }
           // cout<<" "<<count<<endl;
            if(!pq.empty()){
                res->next = pq.top();
                res = res->next;
                pq.pop();
            }
            if(count==len)
                break;
        }
        while(!pq.empty()){
            res->next = pq.top();
            res = res->next;
            pq.pop();        
        }
        res->next = nullptr;
        
        return dummy.next;
    }

    //75- Top K Frequent Elements - https://leetcode.com/problems/top-k-frequent-elements/
    bool static sortByVal(const pair<int, int> &a, 
               const pair<int, int> &b) { 
        return (a.second > b.second); 
    } 
    //public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int>ints_cnt;
        vector<int> res;
        vector<pair<int, int>> vec;
        unordered_map<int, int> :: iterator it;
        
        for(auto i:nums){
            auto it = ints_cnt.find(i);
            if(it == ints_cnt.end()){
                ints_cnt[i]=1;        
            }else{
                ints_cnt[i]++;
            }
        }
        
        // copy key-value pairs from the map to the vector
        unordered_map<int, int> :: iterator it2;
        for (it2=ints_cnt.begin(); it2!=ints_cnt.end(); it2++) 
        {
            vec.push_back(make_pair(it2->first, it2->second));
        }
        
        // sort the vector by increasing order of its pair's second value
        sort(vec.begin(), vec.end(), sortByVal); 
        
        
        // print the vector
	    cout << "The map, sorted by value is: " << endl;
	    for (int i = 0; i < k; i++)
	    {
		    cout << vec[i].first << ": " << vec[i].second << endl;
            res.push_back(vec[i].first);
	    }
        
        return res;   
    }
    //76- Find Median from Data Stream - https://leetcode.com/problems/find-median-from-data-stream/
    //https://medium.com/kode-shaft/find-median-from-data-stream-ffbf44c63b22
class MedianFinder {
     priority_queue<int> left; // maxheap
    priority_queue<int, vector<int>, greater<int>> right; // minheap
    public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {
         if(!left.size() && !right.size()){
            left.push(num);
            return;
        }
        
        if((left.size() + right.size()) % 2){ // odd
            if(num >= left.top()) 
                right.push(num);
            else{
                right.push(left.top());
                left.pop();
                left.push(num);
            }
        }
        else{ // even
            if(num <= right.top()) 
                left.push(num);
            else{
                left.push(right.top());
                right.pop();
                right.push(num);
            }
        }  
    }
    
    double findMedian() {
        if((left.size() + right.size()) % 2) 
            return left.top();
        return (left.top() + right.top()) / 2.0;
    }
    };
};




int main(){
    return 0;
}