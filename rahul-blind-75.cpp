/* Blind LC-75 
1- Two Sum - https://leetcode.com/problems/two-sum/
2- Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
3- Contains Duplicate - https://leetcode.com/problems/contains-duplicate/
4- Product of Array Except Self - https://leetcode.com/problems/product-of-array-except-self/
5- Maximum Subarray - https://leetcode.com/problems/maximum-subarray/
6- Maximum Product Subarray - https://leetcode.com/problems/maximum-product-subarray/
7- Find Minimum in Rotated Sorted Array - https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
8- Search in Rotated Sorted Array - https://leetcode.com/problems/search-in-rotated-sorted-array/
9- 3Sum - https://leetcode.com/problems/3sum/
10- Container With Most Water - https://leetcode.com/problems/container-with-most-water/
Binary
11- Sum of Two Integers - https://leetcode.com/problems/sum-of-two-integers/
12- Number of 1 Bits - https://leetcode.com/problems/number-of-1-bits/
13- Counting Bits - https://leetcode.com/problems/counting-bits/
14- Missing Number - https://leetcode.com/problems/missing-number/
15- Reverse Bits - https://leetcode.com/problems/reverse-bits/
Dynamic Programming
16- Climbing Stairs - https://leetcode.com/problems/climbing-stairs/
17- Coin Change - https://leetcode.com/problems/coin-change/
18- Longest Increasing Subsequence - https://leetcode.com/problems/longest-increasing-subsequence/
19- Longest Common Subsequence -
20- Word Break Problem - https://leetcode.com/problems/word-break/
21- Combination Sum - https://leetcode.com/problems/combination-sum-iv/
22- House Robber - https://leetcode.com/problems/house-robber/
23- House Robber II - https://leetcode.com/problems/house-robber-ii/
24- Decode Ways - https://leetcode.com/problems/decode-ways/
25- Unique Paths - https://leetcode.com/problems/unique-paths/
26- Jump Game - https://leetcode.com/problems/jump-game/
Graph
27- Clone Graph - https://leetcode.com/problems/clone-graph/
28- Course Schedule - https://leetcode.com/problems/course-schedule/
29- Pacific Atlantic Water Flow - https://leetcode.com/problems/pacific-atlantic-water-flow/
30- Number of Islands - https://leetcode.com/problems/number-of-islands/
31- Longest Consecutive Sequence - https://leetcode.com/problems/longest-consecutive-sequence/
32- Alien Dictionary (Leetcode Premium) - https://leetcode.com/problems/alien-dictionary/
33- Graph Valid Tree (Leetcode Premium) - https://leetcode.com/problems/graph-valid-tree/
34- Number of Connected Components in an Undirected Graph (Leetcode Premium) - 
https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
Interval
35- Insert Interval - https://leetcode.com/problems/insert-interval/
36- Merge Intervals - https://leetcode.com/problems/merge-intervals/
37- Non-overlapping Intervals - https://leetcode.com/problems/non-overlapping-intervals/
38- Meeting Rooms (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms/
39- Meeting Rooms II (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms-ii/
Linked List
40- Reverse a Linked List - https://leetcode.com/problems/reverse-linked-list/
41- Detect Cycle in a Linked List - https://leetcode.com/problems/linked-list-cycle/
42- Merge Two Sorted Lists - https://leetcode.com/problems/merge-two-sorted-lists/
43- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
44- Remove Nth Node From End Of List - https://leetcode.com/problems/remove-nth-node-from-end-of-list/
45- Reorder List - https://leetcode.com/problems/reorder-list/
Matrix
46- Set Matrix Zeroes - https://leetcode.com/problems/set-matrix-zeroes/
47- Spiral Matrix - https://leetcode.com/problems/spiral-matrix/
48- Rotate Image - https://leetcode.com/problems/rotate-image/
49- Word Search - https://leetcode.com/problems/word-search/
String
50- Longest Substring Without Repeating Characters - https://leetcode.com/problems/longest-substring-without-repeating-characters/
51- Longest Repeating Character Replacement - https://leetcode.com/problems/longest-repeating-character-replacement/
52- Minimum Window Substring - https://leetcode.com/problems/minimum-window-substring/
53- Valid Anagram - https://leetcode.com/problems/valid-anagram/
54- Group Anagrams - https://leetcode.com/problems/group-anagrams/
55- Valid Parentheses - https://leetcode.com/problems/valid-parentheses/
56- Valid Palindrome - https://leetcode.com/problems/valid-palindrome/
57- Longest Palindromic Substring - https://leetcode.com/problems/longest-palindromic-substring/
58- Palindromic Substrings - https://leetcode.com/problems/palindromic-substrings/
59- Encode and Decode Strings (Leetcode Premium) - https://leetcode.com/problems/encode-and-decode-strings/
Tree
60- Maximum Depth of Binary Tree - https://leetcode.com/problems/maximum-depth-of-binary-tree/
61- Same Tree - https://leetcode.com/problems/same-tree/
62- Invert/Flip Binary Tree - https://leetcode.com/problems/invert-binary-tree/
63- Binary Tree Maximum Path Sum - https://leetcode.com/problems/binary-tree-maximum-path-sum/
64- Binary Tree Level Order Traversal - https://leetcode.com/problems/binary-tree-level-order-traversal/
65- Serialize and Deserialize Binary Tree - https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
66- Subtree of Another Tree - https://leetcode.com/problems/subtree-of-another-tree/
67- Construct Binary Tree from Preorder and Inorder Traversal - 
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
68- Validate Binary Search Tree - https://leetcode.com/problems/validate-binary-search-tree/
69- Kth Smallest Element in a BST - https://leetcode.com/problems/kth-smallest-element-in-a-bst/
70- Lowest Common Ancestor of BST - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
71- Implement Trie (Prefix Tree) - https://leetcode.com/problems/implement-trie-prefix-tree/
72- Add and Search Word - https://leetcode.com/problems/add-and-search-word-data-structure-design/
73- Word Search II - https://leetcode.com/problems/word-search-ii/
Heap
74- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
75- Top K Frequent Elements - https://leetcode.com/problems/top-k-frequent-elements/
76- Find Median from Data Stream - https://leetcode.com/problems/find-median-from-data-stream/
*/

using namespace std;
#include<iostream>
#include<bits/stdc++.h>
#include<vector>
#include<algorithm>

class Solution {
public:
    //1- Two Sum - https://leetcode.com/problems/two-sum/  
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        unordered_map<int, int> m;
        for(int i=0; i<nums.size(); i++){
            if(m.find(target-nums[i])!=m.end()){
                res.emplace_back(i);
                res.emplace_back(m[target-nums[i]]);
                return res;
            }
            m[nums[i]]=i;
        }
        return res;
    }

    //2- Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
    int maxProfit(vector<int>& prices) {
        int lsf = INT_MAX; // least so far
        int op = 0; // overall profit
        int pist = 0; // profit if sold today
        
        for(int i = 0; i < prices.size(); i++){
            if(prices[i] < lsf){ // if we found new buy value which is more smaller then previous one
                lsf = prices[i]; // update our least so far
            }
            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell
            if(op < pist){ // if pist is more then our previous overall profit
                op = pist; // update overall profit
            }
        }
        return op; // return op      
    }

    int maxProfit1(vector<int>& prices) {
        int maax=0;
        int miin=prices[0];
        for(int i=0 ; i<prices.size() ; i++){
            miin=min(prices[i],miin);
            maax=max(prices[i]-miin,maax);
        }
        return maax;     
    }
    //3- Contains Duplicate - https://leetcode.com/problems/contains-duplicate/
    bool containsDuplicate(vector<int>& nums) {
        unordered_map <int, int> mp;
        for (int i = 0; i < nums.size(); i++) {
            if (mp.count(nums[i]) > 0) {
                return true;
            }
            mp[nums[i]] += 1;
        }
        return false;
    }

    //4- Product of Array Except Self - https://leetcode.com/problems/product-of-array-except-self/
    vector<int> productExceptSelf1(vector<int>& nums) {
        int len = nums.size();
        vector<int> left(len,1);
        vector<int> right(len,1);
        vector<int> res(len,1);
        
        left[0] = nums[0];
        for(int i=1; i<len; i++){
            left[i] = left[i-1]*nums[i];
        }
        
        right[len-1]=nums[len-1];
        for(int j=len-2; j>=0; j--){
            right[j] = right[j+1]*nums[j];
        }

        for(int i=0; i<len; i++){
            res[i] = (i-1>=0?left[i-1]:1) * (i+1<len?right[i+1]:1);
        }
        return res;
    }

    vector<int> productExceptSelf(vector<int>& nums) {
        int left = 1, right = 1, n = nums.size();
        vector<int> res(n, 1);
        for(int i=0; i<n; i++) {
            res[i] *= left;
            res[n-i-1] *= right;
            left *= nums[i];
            right *= nums[n-i-1];
        }
        return res;
    }
    
    //5- Maximum Subarray - https://leetcode.com/problems/maximum-subarray/
    int maxSubArray(vector<int>& nums) {
        int sum = 0;
        int maxi= nums[0];
        for(int i =0 ; i<nums.size();i++){
            sum += nums[i];
            maxi = max(maxi,sum);
            if(sum < 0)
                sum = 0;
        }
        return maxi;
    }

    //6- Maximum Product Subarray - https://leetcode.com/problems/maximum-product-subarray/
    int maxProduct1(vector<int>& nums) {
        int n = nums.size();
        vector<int>pre(n), suf(n);
        int mx = nums[0];
        pre[0]=nums[0]; 
        for(int i=1; i<n; i++) {
            if(pre[i-1]!=0) pre[i]=pre[i-1]*nums[i];
            else pre[i]=nums[i];
            mx = max(mx, pre[i]);
        }
        for(int i=n-1; i>=0; i--) {
            if(i==n-1) suf[i]=nums[i];
            else if(suf[i+1]!=0) suf[i]=suf[i+1]*nums[i];
            else suf[i]=nums[i];
            mx = max(mx, suf[i]);
        }
        return mx;    
    }

    int maxProduct(vector<int>& A) {
      // store the result that is the max we have found so far
    int r = A[0];
    int n = A.size();
    // imax/imin stores the max/min product of
    // subarray that ends with the current number A[i]
    for (int i = 1, imax = r, imin = r; i < n; i++) {
        // multiplied by a negative makes big number smaller, small number bigger
        // so we redefine the extremums by swapping them
        if (A[i] < 0)
            swap(imax, imin);

        // max/min product for the current number is either the current number itself
        // or the max/min by the previous number times the current one
        imax = max(A[i], imax * A[i]);
        imin = min(A[i], imin * A[i]);

        // the newly computed max value is a candidate for our global result
        r = max(r, imax);
    }
    return r;
    }

    //7- Find Minimum in Rotated Sorted Array - https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
    // On dividing - one side will be surely sorted and othersise might not
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        if(nums[right] > nums[0]) 
            return nums[0];
        while(left < right){
            int mid = (left + right) / 2;
            if(nums[right] < nums[mid]) 
                left = mid + 1;
            else 
                right = mid;
        }
        return nums[left];
    }

    int findMin1(vector<int>& nums) {
        int low = 0;
        int high = nums.size()-1;
        int miin = INT_MAX;
        
        while(low <= high){
            int mid = (low+high)/2;
            if(nums[mid] <= nums[high]){
                miin = min(nums[mid],miin);
                high = mid-1;
            }else{
                miin = min(nums[low],miin);
                low = mid+1;
            }
        }
        return miin;
    }

    //8- Search in Rotated Sorted Array - https://leetcode.com/problems/search-in-rotated-sorted-array/
    int search(vector<int>& nums, int target) {
        int low=0,high=nums.size()-1;
        
        while(low<=high){
            int mid=(low+high)>>1;
            
            if(nums[mid]==target) 
                return mid;
            
            if(nums[low]<=nums[mid]){
                if(nums[low]<=target && target<=nums[mid]){
                    high=mid-1;
                } else {
                    low=mid+1;
                }
            }
            else{
                if(nums[high]>=target && target>=nums[mid]){
                    low=mid+1;
                }
                else{
                    high=mid-1;
                }
            }
        }
        return -1;
    }

    int search1(vector<int>& nums, int target) {
        int low=0,high=nums.size()-1;
        while(low<high){
            int mid=(low+high)/2;
            if(nums[mid]>nums[high]) low=mid+1;
            else high=mid;
        }
        int point = low;
        low=0,high=nums.size()-1;
        while(low<=high){
            int mid=(low+high)/2;
            int rMid=(mid+point)%nums.size();
            if(nums[rMid]==target) return rMid;
            if(nums[rMid]<target) low=mid+1;
            else high=mid-1;
        }
        return -1;
    }

    //9- 3Sum - https://leetcode.com/problems/3sum/
    vector<vector<int>> threeSum(vector<int>& nums) {
        
        int len = nums.size();
        if(len < 2){
            return {};
        }
        set<pair<int,int>> seen;
        vector<vector<int>> res;
        
        sort(nums.begin(), nums.end());
        for(int i=0; i<len; i++){
            int first = i;
            int second = i+1;
            int end = len-1;
            while(second < end){
                int sum = nums[first] + nums[second] + nums[end];
                if(sum==0){
                    int mi = min(min(nums[first],nums[second]),nums[end]);
                    int ma = max(max(nums[first],nums[second]),nums[end]);
                    if(!seen.count({mi,ma})){
                        res.push_back({nums[first],nums[second],nums[end]});
                    }
                    seen.insert({mi,ma});
                    second++;
                    end--;
                }else if(sum > 0){
                    end--;
                }else{
                    second++;
                }
            }
        }
        return res;
    }

    vector<vector<int>> threeSum1(vector<int>& arr) {
        int n = arr.size();
        if(n == 0)
            return {};
        
        sort(arr.begin(), arr.end());
        vector<vector<int>> res;
        
        for(int i = 0; i <= n - 3; i++)
        {
            int target = - arr[i];
            int low = i + 1;
            int high = n - 1;
    
            while(low < high)
            {
                if(arr[low] + arr[high] == target)
                {
                    res.push_back({arr[i], arr[low], arr[high]});
                    //skip duplicates
                    while(low < high && arr[low] == arr[low + 1]){
                        low++;
                    }
                    //skip duplcates
                    while(low < high && arr[high] == arr[high - 1]){
                        high--;
                    }
                    low++;
                    high--;
                } else if(arr[low] + arr[high] < target) {
                    low++;
                } else {
                    high--;
                }
            }
            //skip duplicates
            while(i < n - 3 && arr[i] == arr[i + 1])
            {
                i++;
            }
        }
        
        return res;
    }

    //10- Container With Most Water - https://leetcode.com/problems/container-with-most-water/
    int maxArea(vector<int>& height) {
        int ans=0,cal=0;
        int i=0,j=height.size()-1;
        while(i<j){
            if(height[i]<height[j]){
                cal=height[i]*(j-i);
                i++;
            }
            else{
                cal=height[j]*(j-i);
                j--;
            }
            ans=max(ans,cal);
        }
        return ans;
    }

    // Bonus -Trapping Rain Water - https://leetcode.com/problems/trapping-rain-water/   (sounds similar to above but different - thing twice)
    int trap(vector<int>& height){
        int n = height.size();
        int left = 0;
        int right = n-1;
        int res = 0;
        int maxleft = 0, maxright=0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left]>=maxleft)
                    maxleft = height[left];
                else    
                    res += maxleft-height[left];
                left++;
            } else {
                if(height[right]>=maxright)
                    maxright = height[right];
                else    
                    res += maxright-height[right];
                right--;
            }
        }
        return res;
    }

    //11- Sum of Two Integers - https://leetcode.com/problems/sum-of-two-integers/
    int getSum1(int a, int b) {
        while(b){
            unsigned c=a&b;
            a=a^b;
            b=c<<1;
        }
        return a;
    }
    
    int getSum(int a, int b) {     
        if(b>0){
             while(b>0){
                a++;
                b--;
            }  
        } else {
            while(b<0)
            {
                a--;
                b++;
            }
        }
        return a;
    }

    //12- Number of 1 Bits - https://leetcode.com/problems/number-of-1-bits/
    int hammingWeight1(uint32_t n) {
        int count=0;
        while(n){
            if(n & 0x1)
                count++;
            n = n >> 1;
        }
        return count;
    }

    int hammingWeight(uint32_t n) {
        int count=0;
        while(n){
            n = n & n-1;
            count++;
        }
        return count;
    }

    //13- Counting Bits - https://leetcode.com/problems/counting-bits/
    vector<int> countBits(int n) {
        vector<int> res;
        for(int i=0; i<=n; i++){
            res.push_back(hammingWeight(i));
        }
        return res;
    }

    //14- Missing Number - https://leetcode.com/problems/missing-number/
    int missingNumber(vector<int>& nums) {
        int xor1 = 0, i = 0;
	    for (i = 0; i < nums.size(); i++) {
		    xor1 = xor1 ^ i ^ nums[i];
	    }
	    return xor1 ^ i;    
    }

    //15- Reverse Bits - https://leetcode.com/problems/reverse-bits/
    uint32_t reverseBits(uint32_t n) {
        uint32_t ans;
        for(int i=0;i<32;i++){
            ans<<=1;
            if(n & 1) 
                ans++;
            n=n>>1;
        }
        return ans;    
    }
/*
16- Climbing Stairs - https://leetcode.com/problems/climbing-stairs/
17- Coin Change - https://leetcode.com/problems/coin-change/
18- Longest Increasing Subsequence - https://leetcode.com/problems/longest-increasing-subsequence/
19- Longest Common Subsequence -
20- Word Break Problem - https://leetcode.com/problems/word-break/
21- Combination Sum - https://leetcode.com/problems/combination-sum-iv/
22- House Robber - https://leetcode.com/problems/house-robber/
23- House Robber II - https://leetcode.com/problems/house-robber-ii/
24- Decode Ways - https://leetcode.com/problems/decode-ways/
25- Unique Paths - https://leetcode.com/problems/unique-paths/
26- Jump Game - https://leetcode.com/problems/jump-game/
*/

    //27- Clone Graph - https://leetcode.com/problems/clone-graph/
    // Definition for a Node.
    class Node {
    public:
    int val;
    vector<Node*> neighbors;
    Node() {
        val = 0;
        neighbors = vector<Node*>();
    }
    Node(int _val) {
        val = _val;
        neighbors = vector<Node*>();
    }
    Node(int _val, vector<Node*> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
    };

    //BFS
    Node* cloneGraph(Node* node) {
        if(node == NULL){ // if node is null, then simply return null
            return NULL;
        }
        unordered_map<Node *, Node *> mp;
        Node* first = new Node(node -> val, {}); // make a copy of first node
        mp[node] = first;
        
        queue<Node*> q; //For bfs, we create queue
        q.push(node); // push into queue
        
        while(q.empty() == false){ // until q. empty == false
            Node* curr = q.front(); // extract front node
            q.pop(); // pop that from queue
            
            for(auto adj: curr -> neighbors){ // now travel in adjcant
                if(mp.find(adj) == mp.end()){ // if not present in map
                    mp[adj] = new Node(adj -> val, {}); // then create copy
                    q.push(adj); // push nto the queue
                }
                
                mp[curr] -> neighbors.push_back(mp[adj]); // in current node push adjcant node
            }
        }
        
        return mp[node];
    }
    //DFS
    void dfs1(Node *key, unordered_map<Node*, Node*>&clone) {
        Node *new_node = new Node(key->val);
        clone[key] = new_node;
        
        for (auto node: key->neighbors) {
            if (clone.find(node) == clone.end())
                dfs1(node, clone);
            new_node->neighbors.push_back(clone[node]);
        }
    }
    Node* cloneGraph1(Node* node) {
        if (!node)
            return nullptr;
        unordered_map<Node*, Node*> clone;
        
        dfs1(node, clone);
        return clone[node];
    }

    /* 28- Course Schedule - https://leetcode.com/problems/course-schedule/
    There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
    For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
    Return true if you can finish all courses. Otherwise, return false.
    */
    /* vis[id]=0 is used for node which is not yet visited, 
       vis[id]=1 is used for the node which is visited and currently its child nodes are being visited and 
       vis[id]=2 done when all the child nodes of a node ("id") are visited and the function returns to parent node of node ("id"). 
       So at that time it is marked as 2 because this node does not require any further traversing.
    */
    bool iscycle(vector<int> adj[],vector<int> &vis,int id){
        if(vis[id]==1)
            return true;
        if(vis[id]==0){
            vis[id]=1;
            for(auto edge : adj[id]){
                if(iscycle(adj,vis,edge))
                    return true;
            }
        }
        vis[id] = 2; //the node is no longer in the recursive stack.
        return false;
    }
    bool canFinish(int n, vector<vector<int>>& pre) {
        vector<int> adj[n];
        
        for(auto edge : pre)
            adj[edge[1]].push_back(edge[0]);
        
        vector<int> vis(n,0);
        for(int i=0;i<n;i++){
            if(iscycle(adj,vis,i))
                return false;
        }
        return true;
    }

/*

29- Pacific Atlantic Water Flow - https://leetcode.com/problems/pacific-atlantic-water-flow/
30- Number of Islands - https://leetcode.com/problems/number-of-islands/
31- Longest Consecutive Sequence - https://leetcode.com/problems/longest-consecutive-sequence/
32- Alien Dictionary (Leetcode Premium) - https://leetcode.com/problems/alien-dictionary/
33- Graph Valid Tree (Leetcode Premium) - https://leetcode.com/problems/graph-valid-tree/
34- Number of Connected Components in an Undirected Graph (Leetcode Premium) - 
https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
Interval
35- Insert Interval - https://leetcode.com/problems/insert-interval/
36- Merge Intervals - https://leetcode.com/problems/merge-intervals/
37- Non-overlapping Intervals - https://leetcode.com/problems/non-overlapping-intervals/
38- Meeting Rooms (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms/
39- Meeting Rooms II (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms-ii/
*/

};




int main(){
    return 0;
}